#! /usr/bin/env python

# Copyright (C) 2012 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import getopt
import re
import sys

import Queue
import threading
import thread

from Bio               import AlignIO

from tfbayes.phylotree import *
from tfbayes.uipac     import *

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "tfbayes-expectation [option]... PHYLOGENETIC_TREE FASTA_FILE..."
    print
    print "Given a set of fasta files from the ChIP experiment and a"
    print "phylogenetic tree, this program computes a motif of the"
    print "alignment. The motif is given as the expectation of the"
    print "nucleotides at each position of the alignment. The result"
    print "can be plotted with `tfbayes-motifformat'."
    print
    print "Options:"
    print "       --prior=Px:Px:Px:Px:Px         - counts for the prior"
    print "   -t, --threads=N                    - run N jobs in parallel"
    print
    print "   -h, --help                         - print help"
    print "   -v, --verbose                      - be verbose"
    print

# options
# ------------------------------------------------------------------------------

options = {
    'phylotree'      : None,
    'leafmap'        : None,
    'prior'          : [0.1, 0.1, 0.1, 0.1, 0.1],
    'format'         : 'maf',
    'threads'        : 1,
    'verbose'        : False,
    }

# some tools
# ------------------------------------------------------------------------------

def print_result(container):
    print '>%s' % os.path.basename(container['file_name'])
    for result in container['result']:
        for i in range(5):
            print '%11.8f' % result[i],
        print ";"

def code_nucleotide(char):
    if char == 'N' or char == 'n' or char == "-":
        return 4.0
    else:
        return float(DNA.code(char))

# main logic comes here
# ------------------------------------------------------------------------------

def alignment_expectation(multiple_alignment, phylotree):
    """For every column in the alignment, approximate the likelihood
    given by the phylogenetic tree by a simple multinomial
    distribution with averaged count statistics."""
    leafmap   = options['leafmap']
    num_leafs = pt_num_leafs(phylotree)

    # initialize leafs to '-'
    #observations = [ DNA.code('-') ]*num_leafs

    # initialize leafs to -1 meaning that all species that are not present in
    # this alignment will be fully ignored by the phylogenetic model
    observations = [ -1.0 ]*num_leafs

    result = []
    for i in range(len(multiple_alignment[0])):
        # fill observations array
        for alignment in multiple_alignment:
            name = alignment.name.split(".")[0]
            if leafmap.has_key(name):
                observations[leafmap[name]] = code_nucleotide(alignment.seq[i])
        # call phylotree library
        expectation = pt_expectation(phylotree, observations, options['prior'])
        result.append(expectation)
    return result

# parse alignment
# ------------------------------------------------------------------------------

def get_alignment(file_name):
    # use biopython to parse the alignment file
    if options['format'] == 'maf':
        return AlignIO.parse(file_name, options['format'])
    else:
        return AlignIO.read(file_name, options['format'])

# threading
# ------------------------------------------------------------------------------

class ComputationThread(threading.Thread):
    def __init__(self, queue_in, queue_out, mutex):
        threading.Thread.__init__(self)
        self.queue_in  = queue_in
        self.queue_out = queue_out
        self.mutex     = mutex
        self.phylotree = pt_clone(options['phylotree'])
    def __del__(self):
        pt_destroy(self.phylotree)
    def run(self):
        while True:
            job = self.queue_in.get()
            if options['verbose']:
                # to print a message we need to acquire the mutex
                # to messages to not appear scrambled
                self.mutex.acquire()
                print >> sys.stderr, 'Processing %s sequence %d.' % (job['file_name'], job['id'])
                self.mutex.release()
            # compute expectations
            result = alignment_expectation(job['alignment'], self.phylotree)
            if result:
                container = {
                    'result'       : result,
                    'file_name'    : job['file_name'],
                    'id'           : job['id'] }
                self.queue_out.put((job['id'], container))
            self.queue_in.task_done()

def launch_threads(jobs):
    mutex     = thread.allocate_lock()
    queue_in  = Queue.Queue()
    queue_out = Queue.PriorityQueue()
    threads   = []
    # launch daemon threads
    if not threads:
        for i in range(options['threads']):
            t = ComputationThread(queue_in, queue_out, mutex)
            t.setDaemon(True)
            t.start()
            threads += [t]
    # fill input queue
    for job in jobs:
        queue_in.put(job)
    queue_in.join()
    # process output
    while not queue_out.empty():
        container = queue_out.get()[1]
        print_result(container)

# go through the list of fasta files and package them nicely as jobs
# ------------------------------------------------------------------------------

def main_fasta(files):
    jobs = []
    for idx, fasta_file in enumerate(files):
        job = {
            'file_name' : fasta_file,
            'alignment' : get_alignment(fasta_file),
            'id'        : idx }
        jobs.append(job)

    launch_threads(jobs)

def main_maf(files):
    jobs = []
    n    = 0
    for maf_file in files:
        alignment_list = get_alignment(maf_file)
        # maf files usually contain multiple alignment blocks
        for alignment in alignment_list:
            n = n + 1
            job = {
                'file_name' : maf_file,
                'alignment' : alignment,
                'id'        : n }
            jobs.append(job)

    launch_threads(jobs)

# __main__
# ------------------------------------------------------------------------------

def __main__():
    global options
    try:
        longopts   = ["prior=", "threads=", "help", "verbose"]
        opts, tail = getopt.getopt(sys.argv[1:], "t:hv", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    if len(tail) < 2:
        usage()
        return 1
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "--prior":
            options['prior'] = map(float, a.split(':'))
            if not len(options['prior']) == 5:
                usage()
                return 1
        if o in ("-t", "--threads"):
            options['threads'] = int(a)
            if not options['threads'] >= 1:
                usage()
                return 1
    # tail
    options['phylotree'] = pt_parse_file(tail[0])
    options['leafmap']   = pt_create_map(options['phylotree'])
    # call main with files as argument
    if options['format'] == 'fasta':
        main_fasta(tail[1:])
    elif options['format'] == 'maf':
        main_maf(tail[1:])
    else:
        usage()
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(__main__())
