#! /usr/bin/env python

# Copyright (C) 2011 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import re
import math
import time
import ConfigParser
import sys
import getopt
import os

import networkx as nx
try:
    from networkx import graphviz_layout
except ImportError:
    raise ImportError("This example needs Graphviz and either PyGraphviz or Pydot")

import numpy               as     np
import numpy.random.mtrand as     mt
import numpy.random        as     rd

from tfbayes.fasta import fasta
from tfbayes.motif import fileio
from tfbayes.motif import information
from tfbayes.motif import tools
from tfbayes.motif import plot

from tfbayes.uipac.alphabet import DNA

def importMatplotlib(backend=None):
    global pyplot
    global NonUniformImage
    global PdfPages
    global patches
    global path
    from matplotlib import use
    if backend:
        use(backend)
    import matplotlib.pyplot   as     pyplot
    from   matplotlib.image    import NonUniformImage
    from   matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.patches  as     patches
    import matplotlib.path     as     path

# global options
# ------------------------------------------------------------------------------

options = {
    'threshold'    : 0.005,
    'with-prior'   : True,
    'plot'         : False,
    'tfbs_length'  : None,
    'result_file'  : None,
    'seq_file'     : None,
    'load'         : None,
    'save'         : None,
    'interactive'  : False,
    'verbose'      : False,
    }

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "tfbayes-graph [option]... SAMPLER_CONFIG"
    print
    print "Options:"
    print "   -p, --plot                     - plot motifs"
    print "       --with-prior=Yes|No        - generate motif with uniform prior [default: Yes]"
    print "       --result=FILE              - sampler result file"
    print "       --sequences=FILE           - fasta sequences file"
    print "       --threshold=DOUBLE         - cut edges that are below threshold"
    print
    print "   -l, --load=FILE                - load motifs from FILE"
    print "   -s, --save=FILE                - save motifs to FILE"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# parse results config
# ------------------------------------------------------------------------------

def read_vector(config, section, option, converter):
    vector_str = config.get(section, option)
    vector     = map(converter, vector_str.split(' '))
    return vector

def read_matrix(config, section, option, converter):
    matrix_str = config.get(section, option)
    matrix     = []
    for line in matrix_str.split('\n'):
        if line != '':
            matrix.append([converter(a) for a in line.split(' ')])
    return matrix

def parse_config(config_file):
    config_parser = ConfigParser.RawConfigParser()
    config_parser.read(config_file)
    if not config_parser.has_section('TFBS-Sampler'):
        raise IOError("Invalid configuration file.")
    options['seq_file'] = config_parser.get('TFBS-Sampler', 'sequences')
    options['tfbs_length'] = int(config_parser.get('TFBS-Sampler', 'tfbs-length'))
    if config_parser.has_option('TFBS-Sampler', 'save'):
        options['result_file'] = config_parser.get('TFBS-Sampler', 'save')

def parse_result(config_parser):
    edges = map(lambda s: s.strip(), read_vector(config_parser, 'Result', 'graph', str))
    return edges

# parse sequences file
# ------------------------------------------------------------------------------

def makefilter(keep):
    """ Return a functor that takes a string and returns a copy of that
        string consisting of only the characters in 'keep'.
    """
    import string

    # make a string of all chars, and one of all those NOT in 'keep'
    allchars = string.maketrans('', '')
    delchars = ''.join([c for c in allchars if c not in keep])

    # return the functor
    return lambda s,a=allchars,d=delchars: s.translate(a, d)

def read_sequences(seq_file):
    parser = fasta.parser(seq_file)
    seqfilter = makefilter('ACGTacgtN')
    descriptions = []
    sequences    = []
    while 1:
        description, line = parser.read_sequence()
        if not line:
            break
        descriptions.append(description[0])
        sequences.append(seqfilter(line))
    return descriptions, sequences

# generate motifs
# ------------------------------------------------------------------------------

def generate_motif(sequences, Gi, motif_length):
    sum_degrees  = sum([ Gi.degree(v, weighted=True) for v in Gi ])
    motif = [ [ 0.0 for j in range(0, motif_length) ] for i in range(0, 4) ]
    mixture_weights = [ float(Gi.degree(v, weighted=True))/sum_degrees for v in Gi ]
    for node, weight in zip(Gi.nodes(), mixture_weights):
        s = int(node.split(':')[0][1:])
        p = int(node.split(':')[1][:-1])
        for j in range(0, motif_length):
            if sequences[s][p+j] == 'A' or sequences[s][p+j] == 'a':
                code = DNA.code('A')
                motif[code][j] += weight
            if sequences[s][p+j] == 'C' or sequences[s][p+j] == 'c':
                code = DNA.code('C')
                motif[code][j] += weight
            if sequences[s][p+j] == 'G' or sequences[s][p+j] == 'g':
                code = DNA.code('G')
                motif[code][j] += weight
            if sequences[s][p+j] == 'T' or sequences[s][p+j] == 't':
                code = DNA.code('T')
                motif[code][j] += weight
    if options['with-prior']:
        components = len(Gi)+1
        motif = [ [ 0.25/components + float(components-1)/components*motif[i][j] for j in range(0, motif_length) ] for i in range(0, 4) ]
    else:
        components = len(Gi)
    return motif, components

def generate_motifs(sequences, G, motif_length):
    Gcc = nx.connected_component_subgraphs(G)
    motifs = []
    motif_counts = []
    components = []
    for n, Gi in zip(range(0, len(Gcc)), Gcc):
        motif, comp = generate_motif(sequences, Gi, motif_length)
        motifs.append(motif)
        components.append(comp)
    return motifs, components

# graph construction
# ------------------------------------------------------------------------------

def construct_graph(edges):
    G = nx.Graph()
    for edge in edges:
        e, w = edge.split('=')
        a, b = e.split('-')
        if float(w) > options['threshold']:
            G.add_edge(a, b, weight=float(w))
    return G

# plot
# ------------------------------------------------------------------------------

font = {'color'      : 'k',
        'fontweight' : 'bold',
        'fontsize'   : 14}

def plot_graph(G):
#    pos = nx.graphviz_layout(G, prog='twopi', args='')
#    pos = nx.graphviz_layout(G, prog='dot', args='')
#    pos = nx.graphviz_layout(G, prog='neato', args='')
    pos = nx.graphviz_layout(G, prog='circo', args='')
#    pos = nx.graphviz_layout(G, prog='nop', args='')
#    pos = nx.spring_layout(G)

    # create figure
    fig = pyplot.figure()
    ax  = fig.add_subplot(1,1,1)

    # compute edge and node sizes
    edgewidth  = [ d['weight'] for (u, v, d) in G.edges(data = True) ]
    max_weight = max(edgewidth)
    edgewidth  = [ 10.0*weight/max_weight for weight in edgewidth ]
    node_size  = [G.degree(v, weighted=True) for v in G]
    max_size   = max(node_size)
    node_size  = [ 500.0*size/max_size for size in node_size]

    # plot cluster labels
    Gcc = nx.connected_component_subgraphs(G)
    for n, Gi in zip(range(0, len(Gcc)), Gcc):
        center = map(lambda x: sum(x)/float(len(x)), zip(*[ pos[node] for node in Gi ]))
        ax.text(center[0], center[1]+10, 'Cluster %d' % n, font, alpha=0.2, ha='center', va='top')

    # plot graph
    nx.draw(G, pos, node_size=node_size, alpha=0.6, cmap=pyplot.cm.Reds_r, ax=ax)
    nx.draw_networkx_edges(G, pos, width=edgewidth, edge_color='r', alpha=0.2, ax=ax)

    pyplot.show()

def plot_result(G):
    if options['save']:
        importMatplotlib('Agg')
    else:
        importMatplotlib()
    plot_graph(G)

# main
# ------------------------------------------------------------------------------

def __main__():
    config_parser_results = ConfigParser.ConfigParser()
    config_parser_results.read(options['result_file'])
    edges = parse_result(config_parser_results)
    descriptions, sequences = read_sequences(options['seq_file'])
    G = construct_graph(edges)
    if options['plot'] or options['save']:
        if options['save']:
            config_parser_save = ConfigParser.ConfigParser()
            config_parser_save.read(options['save'])
        if options['load']:
            config_parser_load = ConfigParser.ConfigParser()
            config_parser_load.read(options['load'])
            bg, motifs, components = fileio.load_motifs(config_parser_load)
        else:
            if config_parser_results.has_option('Result', 'cluster_bg'):
                bg_counts = read_matrix(config_parser_results, 'Result', 'cluster_bg', int)
            else:
                print "Warning: using default background counts."
                bg_counts = [[0], [0], [0], [0]]
                bg_counts[DNA.code('G')][0] = 2000
                bg_counts[DNA.code('A')][0] = 3000
                bg_counts[DNA.code('T')][0] = 3000
                bg_counts[DNA.code('C')][0] = 2000
            bg = tools.compute_frequencies(bg_counts)
            motifs, components = generate_motifs(sequences, G, options['tfbs_length'])
        if options['plot']:
            plot.plot_motifs(motifs, components, os.path.splitext(os.path.split(options['result_file'])[1])[0])
        if options['save']:
            fileio.save_motifs(config_parser_save, bg, motifs, components)
            configfile = open(options['save'], 'wb')
            config_parser_save.write(configfile)
    else:
        plot_result(G)

def main():
    global options
    try:
        longopts   = ["help", "verbose", "plot", "with-prior=", "threshold=",
                      "result=", "sequences=", "load=", "save="]
        opts, tail = getopt.getopt(sys.argv[1:], "pls:v", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    if len(tail) != 1:
        usage()
        return 1
    # option default options from config file
    parse_config(*tail)
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "--with-prior":
            if a == "Yes" or a == "yes":
                options['with-prior'] = True
            if a == "No" or a == "no":
                print "Neglecting uniform prior!"
                options['with-prior'] = False
        if o in ("-p", "--plot"):
            options['plot'] = True
        if o == "--result":
            options['result_file'] = a
        if o == "--sequences":
            options['seq_file'] = a
        if o in ("-l", "--load"):
            options['load'] = a
        if o in ("-s", "--save"):
            options['save'] = a
        if o == "--threshold":
            options['threshold'] = float(a)
    # check if all required options are specified
    if not options['tfbs_length']:
        raise IOError('tfbs length is unknown')
    if not options['result_file']:
        raise IOError('no result file specified')
    if not options['seq_file']:
        raise IOError('no sequences file specified')
    # call __main__ and exit
    __main__()
    return 0

if __name__ == "__main__":
    sys.exit(main())
