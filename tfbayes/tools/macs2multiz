#! /usr/bin/env python

# Copyright (C) 2012 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import getopt
import re
import sys

import Queue
import threading
import thread

from Bio         import AlignIO
from Bio.AlignIO import MafIO

from tfbayes.phylotree      import *
from tfbayes.uipac.alphabet import DNA

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "macs2multiz [option]... MACS_FILE"
    print
    print "Options:"
    print "   -d DIR                         - directory containing multiz alignments"
    print "   -f FORMAT                      - output format [default: maf]"
    print "   -p FILE                        - instead of printing the raw multiz alignments"
    print "                                    the phylogenetic tree in FILE is used to compute"
    print "                                    the expected sequence logos"
    print "       --prior=Px:Px:Px:Px:Px     - counts for the prior"
    print "   -r REFSEQ                      - reference sequence [default: hg18]"
    print "   -t, threads=N                  - run N jobs in parallel"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# options
# ------------------------------------------------------------------------------

options = {
    'database_dir'  : None,
    'macs_file'     : None,
    'phylotree'     : None,
    'leafmap'       : None,
    'threads'       : 1,
    'prior'         : [1.0, 1.0, 1.0, 1.0, 1.0],
    'refseq'        : 'hg18',
    'output_format' : 'maf',
    'verbose'       : False,
    }

# multiz2logo
# ------------------------------------------------------------------------------

def print_result(result):
    print '>%s' % result['name']
    for expectation in result['expectations']:
        for i in range(4):
            print '%.10f' % expectation[i],
        print

def reweight(expectation):
    return [ expectation[i]/(1.0-expectation[4]) for i in range(4) ]

def code_nucleotide(char):
    if char == 'N' or char == 'n' or char == "-":
        return 4.0
    else:
        return float(DNA.code(char))

def alignment_to_logo(multiple_alignment):
    phylotree = options['phylotree']
    leafmap   = options['leafmap']
    num_leafs = pt_num_leafs(phylotree)
    observations = [ 4.0 ]*num_leafs

    # get reference index
    refindex = None
    for i in range(len(multiple_alignment)):
        name = multiple_alignment[i].name.split(".")[0]
        if options['refseq'] == name:
            refindex = i

    if refindex == None:
        print >> sys.stderr, 'Reference sequence not found in multiple alignment.'
        return None

    result = []
    for i in range(len(multiple_alignment[0])):
        # filter all positions where the reference sequence has a gap
        if multiple_alignment[refindex][i] == '-':
            continue
        # fill observations array
        for alignment in multiple_alignment:
            name = alignment.name.split(".")[0]
            if leafmap.has_key(name):
                observations[leafmap[name]] = code_nucleotide(alignment.seq[i])
        # call phylotree library
        expectation = pt_expectation(phylotree, observations, options['prior'])
        result.append(reweight(expectation))
    return result

# database operations
# ------------------------------------------------------------------------------

def get_alignment(chromosome, seq_start, seq_end):
    if options['database_dir']:
        mafindex   = "%s/%s.mafindex" % (options['database_dir'], chromosome)
        maf        = "%s/%s.maf"      % (options['database_dir'], chromosome)
    else:
        mafindex   = "%s.mafindex" % chromosome
        maf        = "%s.maf"      % chromosome
    seqname = "%s.%s" % (options['refseq'], chromosome)

    idx = MafIO.MafIndex(mafindex, maf, seqname)

    multiple_alignment = idx.get_spliced([seq_start],
                                         [seq_end],
                                         strand = "+")

    return multiple_alignment

# threading
# ------------------------------------------------------------------------------

class ComputationThread(threading.Thread):
    def __init__(self, queue_in, queue_out, mutex):
        threading.Thread.__init__(self)
        self.queue_in  = queue_in
        self.queue_out = queue_out
        self.mutex     = mutex
    def run(self):
        while True:
            job = self.queue_in.get()
            self.mutex.acquire()
            if options['verbose']:
                print >> sys.stderr, 'Processing %s.' % job['name']
            self.mutex.release()
            alignment = get_alignment(job['chromosome'], job['seq_start'], job['seq_end'])
            logo      = alignment_to_logo(alignment)
            if logo:
                result = {
                    'expectations' : logo,
                    'name'         : job['name'],
                    'id'           : job['id'] }
                self.queue_out.put((job['id'], result))
            self.queue_in.task_done()

def threaded_logo_computation(alignments):
    mutex     = thread.allocate_lock()
    queue_in  = Queue.Queue()
    queue_out = Queue.PriorityQueue()
    threads   = []
    # launch daemon threads
    if not threads:
        for i in range(options['threads']):
            t = ComputationThread(queue_in, queue_out, mutex)
            t.setDaemon(True)
            t.start()
            threads += [t]
    # fill input queue
    for elem in alignments:
        queue_in.put(elem)
    queue_in.join()
    # process output
    while not queue_out.empty():
        result = queue_out.get()[1]
        print_result(result)

# parse macs file
# ------------------------------------------------------------------------------

def process_entries(entries):
    if options['phylotree']:
        threaded_logo_computation(entries)
    else:
        for entry in entries:
            alignment = get_alignment(entry['chromosome'], entry['seq_start'], entry['seq_end']),
            AlignIO.write(alignment, sys.stdout, options['output_format'])


def parse_macs():
    fp = open(options['macs_file'], 'r')
    pattern = re.compile('^(chr[XY0-9]+)[ \t]([0-9]+)[ \t]([0-9]+)')
    n = 0

    # print prior if verbose
    if options['verbose']:
        print >> sys.stderr, "Prior:",
        for i in range(len(options['prior'])-1):
            print >> sys.stderr, '%s:%f,' % (DNA.decode(i), options['prior'][i]),
        print >> sys.stderr, '%s:%f' % ('Nil', options['prior'][4])

    # parse macs file
    entries = []
    for line in fp:
        m = pattern.match(line)
        if m:
            n = n + 1
            entry = {
                'chromosome' : m.group(1),
                'seq_start'  : int(m.group(2)),
                'seq_end'    : int(m.group(3)),
                'name'      : 'peak_%04d' % n,
                'id'        : n }
            entries.append(entry)

    fp.close()
    process_entries(entries)

# main
# ------------------------------------------------------------------------------

def main():
    global options
    try:
        longopts   = ["prior=", "threads=", "help", "verbose"]
        opts, tail = getopt.getopt(sys.argv[1:], "d:f:p:r:t:hv", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    if len(tail) != 1:
        usage()
        return 1
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "-d":
            options['database_dir'] = a
        if o == "-f":
            options['output_format'] = a
        if o == "-r":
            options['refseq'] = a
        if o == "-p":
            options['phylotree'] = pt_parse_file(a)
            options['leafmap']   = pt_create_map(options['phylotree'])
        if o == "--prior":
            options['prior'] = map(float, a.split(':'))
            if not len(options['prior']) == 5:
                usage()
                return 1
        if o in ("-t", "--threads"):
            options['threads'] = int(a)
            if not options['threads'] >= 1:
                usage()
                return 1
    # tail
    options['macs_file'] = tail[0]
    # parse macs file and exit
    parse_macs()
    return 0

if __name__ == "__main__":
    sys.exit(main())
