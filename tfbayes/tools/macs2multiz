#! /usr/bin/env python

# Copyright (C) 2012 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import getopt
import re
import sys

from Bio         import AlignIO
from Bio.AlignIO import MafIO

from tfbayes.phylotree      import *
from tfbayes.uipac.alphabet import DNA

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "macs2multiz [option]... MACS_FILE"
    print
    print "Options:"
    print "   -d DIR                         - directory containing multiz alignments"
    print "   -f FORMAT                      - output format [default: maf]"
    print "   -p FILE                        - instead of printing the raw multiz alignments"
    print "                                    the phylogenetic tree in FILE is used to compute"
    print "                                    the expected sequence logos"
    print "   -r REFSEQ                      - reference sequence [default: hg18]"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# options
# ------------------------------------------------------------------------------

options = {
    'database_dir'  : None,
    'macs_file'     : None,
    'phylotree'     : None,
    'leafmap'       : None,
    'refseq'        : 'hg18',
    'output_format' : 'maf',
    'verbose'       : False,
    }

# multiz2logo
# ------------------------------------------------------------------------------

def reweight_and_print(expectation):
    for i in range(4):
        print '%.10f' % (expectation[i]/(1.0-expectation[4])),
    print

def code_nucleotide(char):
    if char == 'N' or char == "-":
        return 4.0
    else:
        return float(DNA.code(char))

def alignment_to_logo(multiple_alignment, name):
    phylotree = options['phylotree']
    leafmap   = options['leafmap']
    num_leafs = pt_num_leafs(phylotree)
    observations = [ 4.0 ]*num_leafs
    prior        = [ 1.0 ]*5

    print '>%s' % name

    for i in range(len(multiple_alignment[0])):
        # fill observations array
        for alignment in multiple_alignment:
            name = alignment.name.split(".")[0]
            if leafmap.has_key(name):
                observations[leafmap[name]] = code_nucleotide(alignment.seq[i])
        # call phylotree library
        expectation = pt_expectation(phylotree, observations, prior)
        reweight_and_print(expectation)

# macs2multiz
# ------------------------------------------------------------------------------

def get_alignment(chromosome, seq_start, seq_end):
    if options['database_dir']:
        mafindex   = "%s/%s.mafindex" % (options['database_dir'], chromosome)
        maf        = "%s/%s.maf"      % (options['database_dir'], chromosome)
    else:
        mafindex   = "%s.mafindex" % chromosome
        maf        = "%s.maf"      % chromosome
    seqname = "%s.%s" % (options['refseq'], chromosome)

    idx = MafIO.MafIndex(mafindex, maf, seqname)

    multiple_alignment = idx.get_spliced([seq_start],
                                         [seq_end],
                                         strand = "+")

    return multiple_alignment

def process_alignment(alignment, name):
    if options['phylotree']:
        alignment_to_logo(alignment, name)
    else:
        AlignIO.write(alignment, sys.stdout, options['output_format'])

def parse_macs():
    fp = open(options['macs_file'], 'r')
    pattern = re.compile('^(chr[XY0-9]+)[ \t]([0-9]+)[ \t]([0-9]+)')
    n = 0

    for line in fp:
        m = pattern.match(line)
        if m:
            n = n + 1
            if options['verbose']:
                print >> sys.stderr, 'Processing peak %d.' % n
            alignment = get_alignment(m.group(1), int(m.group(2)), int(m.group(3)))
            process_alignment(alignment, 'peak_%d' % n)

    fp.close()

# main
# ------------------------------------------------------------------------------

def main():
    global options
    try:
        longopts   = ["help", "verbose"]
        opts, tail = getopt.getopt(sys.argv[1:], "d:f:p:r:hv", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    if len(tail) != 1:
        usage()
        return 1
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "-d":
            options['database_dir'] = a
        if o == "-f":
            options['output_format'] = a
        if o == "-r":
            options['refseq'] = a
        if o == "-p":
            options['phylotree'] = pt_parse_file(a)
            options['leafmap']   = pt_create_map(options['phylotree'])
    # tail
    options['macs_file'] = tail[0]
    # parse macs file and exit
    parse_macs()
    return 0

if __name__ == "__main__":
    sys.exit(main())
