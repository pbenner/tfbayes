#! /usr/bin/env python

# Copyright (C) 2012 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import re
import math
import time
import ConfigParser
import sys
import getopt
import os
import subprocess

import numpy               as     np
import numpy.random.mtrand as     mt
import numpy.random        as     rd

from tfbayes.fasta   import *
from tfbayes.cluster import *
from tfbayes.uipac   import *
from tfbayes.config  import *

def importMatplotlib(backend=None):
    global pyplot
    global NonUniformImage
    global PdfPages
    global patches
    global path
    from matplotlib import use
    if backend:
        use(backend)
    import matplotlib.pyplot   as     pyplot
    from   matplotlib.image    import NonUniformImage
    from   matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.patches  as     patches
    import matplotlib.path     as     path

# global options
# ------------------------------------------------------------------------------

sampler_config = {
    'baseline_priors'  : [],
    'seq_file'         : None,
    'tfbs_length'      : None,
    'save'             : None,
    }

options = {
    'plot'             : False,
    'revcomp'          : False,
    'join'             : False,
    'load'             : None,
    'save'             : None,
    'verbose'          : False,
    }

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "tfbayes-partition [option]... SAMPLER_CONFIG"
    print
    print "This program is used to generate motifs from the MAP partition"
    print "of ChIP data. Motifs can be either plotted or saved as counts."
    print
    print "Options:"
    print "   -j, --join                     - join plots with pdftk"
    print "   -r                             - also plot reverse complements"
    print
    print "   -l, --load=FILE                - load motifs from FILE"
    print "   -s, --save=FILE                - save motifs to FILE"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# parse results config
# ------------------------------------------------------------------------------

class dpm_subset_t():
    # the identifier gives the cluster type, i.e. which component model
    # or prior the subset represents
    identifier = None
    subset     = None

def parse_partition_identifier(partition_str, end):
    # start is the position of '{', we want the identifier
    # before this bracket
    start = 0
    if not partition_str[end-1] == ':':
        raise ValueError('Invalid MAP partition.')
    for i in range(end-1,-1,-1):
        if (partition_str[i] == ' ' or partition_str[i] == ','):
            start = i+1
            break
    return int(partition_str[start:end-1])

def parse_partition_subsets(partition_str):
    """Split the partition string into a list of its subsets."""
    stack = []
    for i, c in enumerate(partition_str):
        if c == '{':
            stack.append(i)
        elif c == '}' and stack:
            start      = stack.pop()
            identifier = parse_partition_identifier(partition_str, start)
            yield identifier, partition_str[start + 1: i]

def parse_partition_elements(subset_str):
    """Split the string of a subset into its elements and parse them."""
    stack = []
    for i, c in enumerate(subset_str):
        if c == '(':
            stack.append(i)
        elif c == ')' and stack:
            start = stack.pop()
            element = subset_str[start + 1: i].split(':')
            yield (int(element[0]), int(element[1]))

def parse_partition(results_config):
    partition = []
    for identifier, subset in parse_partition_subsets(results_config['map_partition']):
        dpm_subset = dpm_subset_t()
        dpm_subset.identifier = identifier
        dpm_subset.subset     = list(parse_partition_elements(subset))
        partition.append(dpm_subset)
    return partition

# parse sequences file
# ------------------------------------------------------------------------------

def filter_line(line):
    line = re.sub(r'\s+', ' ', line).strip()
    line = line.split(';')
    line.remove('')
    line = map(lambda s: s.strip(), line)
    return line

def parse_line(lines):
    return map(lambda s:
                  map(lambda e: float(e), s.split(' ')),
              lines)

def parse_sequences(seq_file):
    parser = fasta.parser(seq_file)
    descriptions = []
    sequences    = []
    while 1:
        description, line = parser.read_sequence()
        if not line:
            break
        lines = filter_line(line)
        descriptions.append(description[0])
        sequences.append(parse_line(lines))
    return descriptions, sequences

# sort cluster
# ------------------------------------------------------------------------------

def update_identifier(cluster_list):
    for idx, cluster in enumerate(cluster_list):
        cluster.identifier = idx
    return cluster_list

def permutation_indices(scores):
     return sorted(range(len(scores)), key = scores.__getitem__, reverse=True)

def sort_cluster_list(cluster_list):
    # the score is the criterion according to which the list of motifs
    # is sorted
    scores = [ cluster.average_counts() for cluster in cluster_list ]
    # sort this list and obtain the permutation pi
    pi     = permutation_indices(scores)
    # return a sorted list of motifs
    return update_identifier([ cluster_list[i] for i in pi ])

# generate motifs
# ------------------------------------------------------------------------------

def generate_cluster(sequences, dpm_subset, identifier):
    counts       = [ [ 0.0 for j in range(sampler_config['tfbs_length']) ] for i in range(4) ]
    counts_gap   = [ 0.0 ] * sampler_config['tfbs_length']
    alpha        = sampler_config['baseline_priors'][dpm_subset.identifier][0:4]
    alpha_gap    = sampler_config['baseline_priors'][dpm_subset.identifier][4]
    components   = len(dpm_subset.subset)
    cluster_type = dpm_subset.identifier
    for position in dpm_subset.subset:
        s = position[0]
        p = position[1]
        # loop over the motif
        for j in range(sampler_config['tfbs_length']):
            # loop over all nucleotides plus counts for gaps
            for i in range(4):
                counts[i][j] += sequences[s][p+j][i]
            counts_gap[j] += sequences[s][p+j][4]
    return cluster_t(counts, counts_gap, alpha, alpha_gap, components, identifier, cluster_type)

def generate_cluster_list(sequences, partition):
    """Loop through the partition and for each subset generate a motif."""
    cluster_list = []
    for idx, dpm_subset in enumerate(partition):
        cluster_list.append(generate_cluster(sequences, dpm_subset, idx))
    return sort_cluster_list(cluster_list)

# plot motifs
# ------------------------------------------------------------------------------

def plot_cluster_list(cluster_list):
    basename = os.path.splitext(os.path.split(sampler_config['save'])[1])[0]
    files    = plot.plot_cluster_list(cluster_list, basename, revcomp=options['revcomp'])
    if options['join']:
        cmd = 'pdftk %s cat output %s_cluster.pdf' % (' '.join(files), basename)
        print cmd
        subprocess.call(cmd, shell=True)
        cmd = 'rm -f %s' % ' '.join(files)
        print cmd
        subprocess.call(cmd, shell=True)

# main
# ------------------------------------------------------------------------------

def main(sampler_config_file):
    results_config = {}
    parse_sampler_config(sampler_config_file, sampler_config)
    # check if all required options are specified
    if not sampler_config['tfbs_length']:
        raise IOError('tfbs length is unknown')
    if not sampler_config['save']:
        raise IOError('no result file specified')
    if not sampler_config['seq_file']:
        raise IOError('no sequences file specified')
    # parse results file
    results_config_file = sampler_config['save']
    parse_results_config(results_config_file, results_config)
    # parse the fasta file
    descriptions, sequences = parse_sequences(sampler_config['seq_file'])
    # parse the map partition
    partition               = parse_partition(results_config)
    if options['save']:
        config_parser_save = ConfigParser.ConfigParser()
        config_parser_save.read(options['save'])
    if options['load']:
        config_parser_load = ConfigParser.ConfigParser()
        config_parser_load.read(options['load'])
        cluster_list = fileio.load_cluster_list(config_parser_load, sampler_config)
    else:
        cluster_list = generate_cluster_list(sequences, partition)
    if options['save']:
        fileio.save_cluster_list(config_parser_save, cluster_list)
        configfile = open(options['save'], 'wb')
        config_parser_save.write(configfile)
    else:
        plot_cluster_list(cluster_list)

def __main__():
    global options
    global sampler_config
    try:
        longopts   = ["help", "verbose", "plot", "join", "load=", "save="]
        opts, tail = getopt.getopt(sys.argv[1:], "rjpls:v", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    if len(tail) != 1:
        usage()
        return 1
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o in ("-j", "--join"):
            options['join'] = True
        if o in ("-p", "--plot"):
            options['plot'] = True
        if o == "-r":
            options['revcomp'] = True
        if o in ("-l", "--load"):
            options['load'] = a
        if o in ("-s", "--save"):
            options['save'] = a
    # call main and exit
    main(tail[0])
    return 0

if __name__ == "__main__":
    sys.exit(__main__())
