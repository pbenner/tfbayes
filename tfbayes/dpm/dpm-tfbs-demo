#! /usr/bin/env python

# Copyright (C) 2011 Philipp Benner
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# imports
# ------------------------------------------------------------------------------

import re
import math
import time
import gobject
import gtk
import sys
import getopt
import os
import cProfile
import ConfigParser

import numpy               as     np
import numpy.random.mtrand as     mt
import numpy.random        as     rd

from tfbayes.fasta import fasta

def importMatplotlib(backend=None):
    global pyplot
    global NonUniformImage
    global patches
    global path
    from matplotlib import use
    if backend:
        use(backend)
    import matplotlib.pyplot   as     pyplot
    from   matplotlib.image    import NonUniformImage
    import matplotlib.patches  as     patches
    import matplotlib.path     as     path

# local imports
# ------------------------------------------------------------------------------

from tfbayes.dpm.dpm_tfbs_interface import *

# global options
# ------------------------------------------------------------------------------

options = {
    'alpha'               : 0.05,
    'discount'            : 0.0,
    'lambda'              : 0.01,
    'metropolis_optimize' : True,
    'process_prior'       : "pitman-yor process",
    'background_model'    : "independence",
    'background_alpha'    : 0.5,
    'background_context'  : 2,
    'background_weights'  : 'decay',
    'samples'             : (1000,100),
    'population_size'     : 1,
    'tfbs_length'         : 10,
    'save'                : None,
    'interactive'         : False,
    'verbose'             : False,
    'baseline_weights'    : [1.0],
    'baseline_priors'     : []
    }

# parse config
# ------------------------------------------------------------------------------

def str2bool(v):
    return v.lower() in ("yes", "true", "t", "1")

def read_vector(config_parser, section, option, converter):
    vector_str = config_parser.get(section, option).replace('  ',' ').strip()
    vector     = map(converter, vector_str.split(' '))
    return vector

def read_matrix(config_parser, section, option, converter):
    matrix_str = config_parser.get(section, option)
    matrix     = []
    for line in matrix_str.split('\n'):
        line = line.replace('  ',' ').strip()
        if line != '':
            matrix.append([converter(a) for a in line.split(' ')])
    return matrix

def parse_config(config_file):
    config_parser = ConfigParser.RawConfigParser()
    config_parser.read(config_file)
    if not config_parser.has_section('TFBS-Sampler'):
        raise IOError("Invalid configuration file.")
    options['input_file'] = config_parser.get('TFBS-Sampler', 'sequences')
    if config_parser.has_option('TFBS-Sampler', 'alpha'):
        options['alpha'] = float(config_parser.get('TFBS-Sampler', 'alpha'))
    if config_parser.has_option('TFBS-Sampler', 'discount'):
        options['discount'] = float(config_parser.get('TFBS-Sampler', 'discount'))
    if config_parser.has_option('TFBS-Sampler', 'lambda'):
        options['lambda'] = float(config_parser.get('TFBS-Sampler', 'lambda'))
    if config_parser.has_option('TFBS-Sampler', 'process-prior'):
        options['process_prior'] = config_parser.get('TFBS-Sampler', 'process-prior').strip()
    if config_parser.has_option('TFBS-Sampler', 'background-model'):
        options['background_model'] = config_parser.get('TFBS-Sampler', 'background-model').strip()
    if config_parser.has_option('TFBS-Sampler', 'background-alpha'):
        options['background_alpha'] = float(config_parser.get('TFBS-Sampler', 'background-alpha'))
    if config_parser.has_option('TFBS-Sampler', 'background-context'):
        options['background_context'] = int(config_parser.get('TFBS-Sampler', 'background-context'))
    if config_parser.has_option('TFBS-Sampler', 'background-weights'):
        options['background_weights'] = config_parser.get('TFBS-Sampler', 'background-weights')
    if config_parser.has_option('TFBS-Sampler', 'tfbs-length'):
        options['tfbs_length'] = int(config_parser.get('TFBS-Sampler', 'tfbs-length'))
    if config_parser.has_option('TFBS-Sampler', 'metropolis-optimize'):
        options['metropolis_optimize'] = str2bool(config_parser.get('TFBS-Sampler', 'metropolis-optimize'))
    if config_parser.has_option('TFBS-Sampler', 'population-size'):
        options['population_size'] = int(config_parser.get('TFBS-Sampler', 'population-size'))
    if config_parser.has_option('TFBS-Sampler', 'save'):
        options['save'] = config_parser.get('TFBS-Sampler', 'save')
    if config_parser.has_option('TFBS-Sampler', 'samples'):
        options['samples'] = tuple(map(int, config_parser.get('TFBS-Sampler', 'samples').split(":")))
    if config_parser.has_option('TFBS-Sampler', 'baseline-weights'):
        options['baseline_weights'] = read_vector(config_parser, 'TFBS-Sampler', 'baseline-weights', int)
    if config_parser.has_option('TFBS-Sampler', 'baseline-priors'):
        for prior_name in read_vector(config_parser, 'TFBS-Sampler', 'baseline-priors', str):
            prior = read_matrix(config_parser, 'TFBS-Sampler', prior_name, float)
            options['baseline_priors'].append(prior)

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "dpm-tfbs-demo [option]... CONFIG"
    print
    print "Options:"
    print "       --alpha=ALPHA              - alpha parameter for the dirichlet process"
    print "       --discount=DISCOUNT        - Pitman-Yor discount (0 <= d < 1)"
    print "       --lambda=LAMBDA            - lambda mixture weight"
    print "       --context=CONTEXT          - context of the background model"
    print "       --process-prior=NAME       - possible process priors:"
    print "                                    pitman-yor process (default),"
    print "                                    uniform process, poppe process"
    print "       --background-model=NAME    - possible background models:"
    print "                                    independence (default),"
    print "                                    markov chain mixture,"
    print "                                    parsimonious tree"
    print "       --tfbs-length=LENGTH       - length of the tfbs"
    print "   -i                             - interactive mode"
    print "   -s, --save=FILE                - save posterior to FILE"
    print "       --samples=SAMPLES:BURN_IN  - number of samples [default: 1000:100]"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# Tfbs DPM
# ------------------------------------------------------------------------------

def cluster_colors(c):
    if c < 5:
        return {
           -1 : 'white',
            0 : 'black',
            1 : 'red',
            2 : 'green',
            3 : 'blue',
            4 : 'yellow'
            }[c]
    else:
        return 'magenta'

def plot_sequences(ax, sequences, clusters):
    ax.set_frame_on(False)
    xn    = max(map(len, sequences))
    yn    = len(sequences)
    yfrom = 0.90
    yto   = yfrom-yn*0.07
    x, y = np.meshgrid(np.arange(0.01, 1.00,  0.99/xn),
                       np.arange(yfrom, yto, -(yfrom-yto)/len(sequences)))
    for sl, cl, p1l, p2l in zip(sequences, clusters, x, y):
        for s, c, p1, p2 in zip(sl, cl, p1l, p2l):
            ax.text(p1, p2, str(s), size=10, rotation=0,
                    ha="center", va="bottom", color=cluster_colors(c), weight='bold')

class TfbsDPM():
    def __init__(self, sequences, clusters, input_file):
        self.sequences = sequences
        self.clusters  = clusters
        self.steps     = 0
        dpm_init(options, input_file)
    def print_clusters(self):
        dpm_print()
    def num_clusters(self):
        return dpm_num_clusters()
    def sample(self, n, burnin):
        dpm_sample(n, burnin)
        self.steps += n
    def plotData(self, ax):
        ax.set_xticks([]); ax.set_yticks([])
        plot_sequences(ax, self.sequences, self.clusters)
    def plotResult(self, ax):
        ax.set_title('Gibbs Sampling')
        ax.set_xticks([]); ax.set_yticks([])
        sequences = np.array(self.sequences)
        clusters = dpm_cluster_assignments()
        plot_sequences(ax, sequences, clusters)
    def plotPosterior(self, ax):
        ax.set_title('Posterior')
        ax.set_xticks([]); ax.set_yticks([])
        X = dpm_get_posterior()
        ax.imshow(X, cmap=pyplot.cm.jet, interpolation='nearest')
    def plotStatistics(self, ax1):
        ax2 = ax1.twinx()
        p1  = ax1.plot(dpm_hist_switches())
        p2  = ax2.plot(dpm_hist_likelihood(), color='green')
        ax1.set_ylabel("Class switches")
        ax2.set_ylabel("Likelihood")
        ax1.set_xlabel("iteration")
        ax1.legend([p1, p2], ["Mean class switches", "Mean likelihood"])

class InteractiveTDPM(TfbsDPM):
    def __init__(self, sequences, clusters, input_file, ax2, ax3):
        TfbsDPM.__init__(self, sequences, clusters[:][:], input_file)
        self.plotResult(ax2)
        self.plotPosterior(ax3)
        manager = pyplot.get_current_fig_manager()
        def updatefig(*args):
            try:
                ax2.cla()
                ax3.cla()
                self.sampleInteractively(1)
                self.plotResult(ax2)
                self.plotPosterior(ax3)
                manager.canvas.draw()
                return True
            except StopIteration:
                return False
        gobject.idle_add(updatefig)
    def sampleInteractively(self, n):
        self.sample(n, 0)

# main
# ------------------------------------------------------------------------------

def readSequences(seq_file):
    parser = fasta.parser(seq_file)
    sequences = []
    clusters  = []
    while 1:
        description, sequence = parser.read_sequence()
        if not sequence:
            break
        sequences.append('')
        clusters.append([])
        for m in re.finditer(r'\(([1-9]):([ACGTN]+)\)|[ACGTN]+', sequence):
            if m.group(2):
                clusters[-1].extend([ int(m.group(1)) for i in range(0, len(m.group(2))) ])
                sequences[-1] = sequences[-1] + m.group(2)
            else:
                clusters[-1].extend([ 0 for i in range(0, len(m.group(0))) ])
                sequences[-1] = sequences[-1] + m.group(0)
    return sequences, clusters

def prepare_plot():
    importMatplotlib('GTKAgg')
    fig1  = pyplot.figure(linewidth=0,facecolor='white',edgecolor='white')
    ax1   = fig1.add_subplot(3,1,1, title='Sequences')
    ax2   = fig1.add_subplot(3,1,2, title='Gibbs Sampling')
    ax3   = fig1.add_subplot(3,1,3, title='Posterior')
    return ax1, ax2, ax3

def sample(sequences, clusters):
    # generate baseline
    if not options['baseline_priors']:
        options['baseline_priors'].append([ [ 1 for j in range(options['tfbs_length']) ] for i in range(4) ])
    if not len(options['baseline_priors']) == len(options['baseline_weights']):
        if options['verbose']:
            print "Setting uniform weights for baseline priors"
        options['baseline_weights'] = [ 1 ] * len(options['baseline_priors'])
    # sample
    if options['interactive']:
        ax1, ax2, ax3 = prepare_plot()
        dpm = InteractiveTDPM(sequences, clusters[:][:], options['input_file'], ax2, ax3)
        dpm.plotData(ax1)
        dpm.sample(0, options['samples'][1])
        dpm.sampleInteractively(options['samples'][0])
        pyplot.show()
    else:
        samples = options['samples'][0]
        burnin  = options['samples'][1]
        dpm = TfbsDPM(sequences, clusters[:][:], options['input_file'])
        dpm.sample(samples, burnin)
        if options['save']:
            dpm_save(options['save'])
        else:
            ax1, ax2, ax3 = prepare_plot()
            dpm.plotData(ax1)
            dpm.plotResult(ax2)
            dpm.plotPosterior(ax3)
            pyplot.show()

def main():
    global options
    try:
        longopts   = ["help", "verbose", "alpha=", "lambda=", "discount=",
                      "context=", "process-prior=", "backround-model=",
                      "tfbs-length=", "save=", "samples="]
        opts, tail = getopt.getopt(sys.argv[1:], "is:vh", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    # option default options from config file
    parse_config(*tail)
    # override those options with command line arguments
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o == "-i":
            options["interactive"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "--alpha":
            options['alpha'] = float(a)
        if o == "--discount":
            if 0 <= float(a) and float(a) < 1:
                options['discount'] = float(a)
            else:
                usage()
                return 1
        if o == "--lambda":
            options['lambda'] = float(a)
        if o == "--context":
            options['context'] = int(a)
        if o == "--process-prior":
            options['process_prior'] = a
        if o == "--background-model":
            options['background_model'] = a
        if o == "--tfbs-length":
            options['tfbs_length'] = int(a)
        if o in ("-s", "--save"):
            options['save'] = a
        if o == "--samples":
            options["samples"] = tuple(map(int, a.split(":")))
    if len(tail) != 1:
        usage()
        return 1
    sequences, clusters = readSequences(options['input_file'])
    sample(sequences, clusters)
    return 0

if __name__ == "__main__":
    sys.exit(main())
