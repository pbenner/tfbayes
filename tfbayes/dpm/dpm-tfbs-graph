#! /usr/bin/env python

# imports
# ------------------------------------------------------------------------------

import re
import math
import time
import ConfigParser
import sys
import getopt
import os
import Bio.Motif as Motif

import networkx as nx
try:
    from networkx import graphviz_layout
except ImportError:
    raise ImportError("This example needs Graphviz and either PyGraphviz or Pydot")

import numpy               as     np
import numpy.random.mtrand as     mt
import numpy.random        as     rd

from tfbayes.fasta import fasta

def importMatplotlib(backend=None):
    global pyplot
    global NonUniformImage
    global PdfPages
    global patches
    global path
    from matplotlib import use
    if backend:
        use(backend)
    import matplotlib.pyplot   as     pyplot
    from   matplotlib.image    import NonUniformImage
    from   matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.patches  as     patches
    import matplotlib.path     as     path

# global options
# ------------------------------------------------------------------------------

options = {
    'threshold'   : 0.005,
    'plot'        : False,
    'save'        : None,
    'interactive' : False,
    'verbose'     : False,
    }

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "dpm-tfbs-graph [option]... RESULT SEQUENCES MOTIF_LENGTH"
    print
    print "Options:"
    print "   -p, --plot                     - plot motifs"
    print "   -s, --save=FILE                - save motifs to FILE"
    print "       --threshold=DOUBLE         - cut edges that are below threshold"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# parse results config
# ------------------------------------------------------------------------------

def read_vector(config, section, option, converter):
    vector_str = config.get(section, option)
    vector     = map(converter, vector_str.split(' '))
    return vector

def read_matrix(config, section, option, converter):
    matrix_str = config.get(section, option)
    matrix     = []
    for line in matrix_str.split('\n'):
        if line != '':
            matrix.append([converter(a) for a in line.split(' ')])
    return matrix

def parse_config(config_file):
    config_parser = ConfigParser.RawConfigParser()
    config_parser.read(config_file)

    edges = map(lambda s: s.strip(), read_vector(config_parser, 'Cluster', 'graph', str))

    return edges

# parse sequences file
# ------------------------------------------------------------------------------

def makefilter(keep):
    """ Return a functor that takes a string and returns a copy of that
        string consisting of only the characters in 'keep'.
    """
    import string

    # make a string of all chars, and one of all those NOT in 'keep'
    allchars = string.maketrans('', '')
    delchars = ''.join([c for c in allchars if c not in keep])

    # return the functor
    return lambda s,a=allchars,d=delchars: s.translate(a, d)

def read_sequences(seq_file):
    parser = fasta.parser(seq_file)
    seqfilter = makefilter('ACGTacgtN')
    descriptions = []
    sequences    = []
    while 1:
        description, line = parser.read_sequence()
        if not line:
            break
        descriptions.append(description[0])
        sequences.append(seqfilter(line))
    return descriptions, sequences

# motif plotting
# ------------------------------------------------------------------------------

class MotifStream():
    def __init__(self, counts):
        self.counts = []
        for line in counts:
            self.counts.append(' '.join(map(str, line)))
        self.counts.append('\n')
        self.counts.append('\n')
        self.i      = 0
    def readline(self):
        if (self.i < len(self.counts)):
            line = self.counts[self.i]
            self.i += 1
            print line
            return line
        else:
            return None

def plot_motif(counts_str, file_name, title):
    stream = MotifStream(counts_str)
    m = Motif.Motif()
    m._from_horiz_matrix(stream, letters='ACGT')
    m.weblogo(file_name, title=title)

# generate motifs
# ------------------------------------------------------------------------------

def generate_motif(sequences, Gi, motif_length):
    components = len(Gi)+1
    maximum_degree  = max([ Gi.degree(v, weighted=True) for v in Gi ])
    mixture_weights = [ float(components-1)/float(components)*float(Gi.degree(v))/float(maximum_degree) for v in Gi ]
    motif = [ [ 1.0/float(components) for j in range(0, motif_length) ] for i in range(0, 4) ]
    for node, weight in zip(Gi.nodes(), mixture_weights):
        s = int(node.split(':')[0][1:])
        p = int(node.split(':')[1][:-1])
        for j in range(0, motif_length):
            if sequences[s][p+j] == 'A' or sequences[s][p+j] == 'a':
                motif[0][j] += weight
            if sequences[s][p+j] == 'C' or sequences[s][p+j] == 'c':
                motif[1][j] += weight
            if sequences[s][p+j] == 'G' or sequences[s][p+j] == 'g':
                motif[2][j] += weight
            if sequences[s][p+j] == 'T' or sequences[s][p+j] == 't':
                motif[3][j] += weight
    return motif

def generate_motifs(sequences, G, motif_length):
    Gcc = nx.connected_component_subgraphs(G)
    motifs = []
    for n, Gi in zip(range(0, len(Gcc)), Gcc):
        motifs.append(generate_motif(sequences, Gi, motif_length))
        counts = [ [ int(round(motif[i][j]*100)) for j in range(0, motif_length) ] for i in range(0, 4) ]
        if options['plot']:
            plot_motif(counts, 'cluster_'+str(n)+'.png', 'cluster_'+str(n)+':'+str(len(Gi)))
        if options['save']:
            save_motif(counts, 'cluster_'+str(n)+'.png', 'cluster_'+str(n)+':'+str(len(Gi)))

# graph construction
# ------------------------------------------------------------------------------

def construct_graph(edges):
    G = nx.Graph()
    for edge in edges:
        e, w = edge.split('=')
        a, b = e.split('-')
        if float(w) > options['threshold']:
            G.add_edge(a, b, weight=float(w))
    return G

# plot
# ------------------------------------------------------------------------------

def plot_graph(G):
#    pos = nx.graphviz_layout(G, prog='twopi', args='')
#    pos = nx.graphviz_layout(G, prog='dot', args='')
#    pos = nx.graphviz_layout(G, prog='neato', args='')
    pos = nx.graphviz_layout(G, prog='circo', args='')
#    pos = nx.graphviz_layout(G, prog='nop', args='')
#    pos = nx.spring_layout(G)
    fig = pyplot.figure()
    edgewidth=[]
    for (u, v, d) in G.edges(data = True):
        edgewidth.append(d['weight'])
    max_weight = max(edgewidth)
    edgewidth  = [ weight/max_weight*10 for weight in edgewidth ]

    nx.draw(G, pos, node_size=[200*G.degree(v, weighted=True) for v in G], alpha=0.6, cmap=pyplot.cm.Reds_r)
    nx.draw_networkx_edges(G, pos, width=edgewidth, edge_color='r', alpha=0.2)

    pyplot.show()

def plot_result(G):
    if options['save']:
        importMatplotlib('Agg')
    else:
        importMatplotlib()
    plot_graph(G)

# main
# ------------------------------------------------------------------------------

def __main__(results_file, seq_file, motif_length):
    edges = parse_config(results_file)
    descriptions, sequences = read_sequences(seq_file)
    G = construct_graph(edges)
    if options['plot'] || options['save']:
        generate_motifs(sequences, G, int(motif_length))
    else:
        plot_result(G)

def main():
    global options
    try:
        longopts   = ["help", "verbose", "plot", "save=", "threshold="]
        opts, tail = getopt.getopt(sys.argv[1:], "ps:", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o in ("-p", "--plot"):
            options['plot'] = True
        if o in ("-s", "--save"):
            options['save'] = a
        if o == "--threshold":
            options['threshold'] = float(a)
    if len(tail) != 3:
        usage()
        return 1
    __main__(*tail)
    return 0

if __name__ == "__main__":
    sys.exit(main())
