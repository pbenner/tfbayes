#! /usr/bin/env python

# imports
# ------------------------------------------------------------------------------

import re
import math
import time
import ConfigParser
import sys
import getopt
import os
import Bio.Motif as Motif

import networkx as nx
try:
    from networkx import graphviz_layout
except ImportError:
    raise ImportError("This example needs Graphviz and either PyGraphviz or Pydot")

import numpy               as     np
import numpy.random.mtrand as     mt
import numpy.random        as     rd

from tfbayes.fasta import fasta

def importMatplotlib(backend=None):
    global pyplot
    global NonUniformImage
    global PdfPages
    global patches
    global path
    from matplotlib import use
    if backend:
        use(backend)
    import matplotlib.pyplot   as     pyplot
    from   matplotlib.image    import NonUniformImage
    from   matplotlib.backends.backend_pdf import PdfPages
    import matplotlib.patches  as     patches
    import matplotlib.path     as     path

# global options
# ------------------------------------------------------------------------------

options = {
    'threshold'   : 0.005,
    'with-prior'  : True,
    'plot'        : False,
    'load'        : None,
    'save'        : None,
    'interactive' : False,
    'verbose'     : False,
    }

# usage
# ------------------------------------------------------------------------------

def usage():
    """Print usage."""
    print
    print "dpm-tfbs-graph [option]... RESULTS_CONFIG SEQUENCES_FASTA MOTIF_LENGTH"
    print
    print "Options:"
    print "   -p, --plot                     - plot motifs"
    print "       --with-prior=Yes|No        - generate motif with uniform prior (default: yes)"
    print "   -l, --load=FILE                - load motifs from FILE"
    print "   -s, --save=FILE                - save motifs to FILE"
    print "       --threshold=DOUBLE         - cut edges that are below threshold"
    print
    print "   -h, --help                     - print help"
    print "   -v, --verbose                  - be verbose"
    print

# parse results config
# ------------------------------------------------------------------------------

def read_vector(config, section, option, converter):
    vector_str = config.get(section, option)
    vector     = map(converter, vector_str.split(' '))
    return vector

def read_matrix(config, section, option, converter):
    matrix_str = config.get(section, option)
    matrix     = []
    for line in matrix_str.split('\n'):
        if line != '':
            matrix.append([converter(a) for a in line.split(' ')])
    return matrix

def write_vector(config, section, option, vector):
    config.set(section, option, " ".join(map(str, vector)))

def write_matrix(config, section, option, matrix):
    config.set(section, option, "\n"+"\n".join(map(lambda arg: " ".join(map(str, arg)), matrix)))

def parse_config(config_parser):
    edges = map(lambda s: s.strip(), read_vector(config_parser, 'Result', 'graph', str))

    return edges

# parse sequences file
# ------------------------------------------------------------------------------

def makefilter(keep):
    """ Return a functor that takes a string and returns a copy of that
        string consisting of only the characters in 'keep'.
    """
    import string

    # make a string of all chars, and one of all those NOT in 'keep'
    allchars = string.maketrans('', '')
    delchars = ''.join([c for c in allchars if c not in keep])

    # return the functor
    return lambda s,a=allchars,d=delchars: s.translate(a, d)

def read_sequences(seq_file):
    parser = fasta.parser(seq_file)
    seqfilter = makefilter('ACGTacgtN')
    descriptions = []
    sequences    = []
    while 1:
        description, line = parser.read_sequence()
        if not line:
            break
        descriptions.append(description[0])
        sequences.append(seqfilter(line))
    return descriptions, sequences

# pwm tools
# ------------------------------------------------------------------------------

def compute_frequencies(counts):
    sums = [ sum(map(lambda m: m[j], counts)) for j in range(0, len(counts[0])) ]
    return [ [ float(counts[i][j])/float(sums[j]) for j in range(0, len(counts[0])) ] for i in range(0, len(counts)) ]

# R_sequence
# ------------------------------------------------------------------------------

def r_sequence(cluster_counts):
    z = 1.0/float(len(cluster_counts[0]))
    cluster_freq = compute_frequencies(cluster_counts)
    return z*sum([ 2 + sum([ cluster_freq[i][j]*math.log(cluster_freq[i][j], 2)
                             for i in range(0, len(cluster_freq)) ])
                   for j in range(0, len(cluster_freq[0])) ])

# motif plotting
# ------------------------------------------------------------------------------

class MotifStream():
    def __init__(self, counts):
        self.counts = []
        for line in counts:
            self.counts.append(' '.join(map(str, line)))
        self.counts.append('\n')
        self.counts.append('\n')
        self.i      = 0
    def readline(self):
        if (self.i < len(self.counts)):
            line = self.counts[self.i]
            self.i += 1
            return line
        else:
            return None

def plot_motifs(motifs, components, basename):
    for n, motif, comp in zip(range(0, len(motifs)), motifs, components):
        r_seq = r_sequence(motif)
        file_name = '%s_cluster_%d.png' % (basename, n)
        title = 'cluster_%d:%d, R_seq = %f' % (n, comp, r_seq)
        print 'Generating %s...' % file_name
        stream = MotifStream(motif)
        m = Motif.Motif()
        m._from_horiz_matrix(stream, letters='ACGT')
        m.weblogo(file_name, title=title)

# load and save motifs
# ------------------------------------------------------------------------------

def save_motifs(config_parser, bg, motifs, components):
    if not config_parser.has_section('Cluster'):
        config_parser.add_section('Cluster')
    cluster_names = []
    for n, motif, comp in zip(range(0, len(motifs)), motifs, components):
        cluster_name = 'cluster_%d' % n
        cluster_names.append(cluster_name)
        write_matrix(config_parser, 'Cluster', cluster_name, motif)
        config_parser.set('Cluster', '%s_components' % cluster_name, str(comp))
    write_vector(config_parser, 'Cluster', 'cluster', cluster_names)
    write_matrix(config_parser, 'Cluster', 'cluster_bg', bg)

def load_motifs(config_parser):
    bg = read_matrix(config_parser, 'Cluster', 'cluster_bg', int)
    motifs = []
    components = []
    cluster_names = read_vector(config_parser, 'Cluster', 'cluster', str)
    for cluster_name in cluster_names:
        motifs.append(read_matrix(config_parser, 'Cluster', cluster_name, int))
        components.append(int(config_parser.get('Cluster', '%s_components' % cluster_name)))
    return bg, motifs, components

# generate motifs
# ------------------------------------------------------------------------------

def generate_motif(sequences, Gi, motif_length):
    maximum_degree  = max([ Gi.degree(v, weighted=True) for v in Gi ])
    if options['with-prior']:
        components = len(Gi)+1
        motif = [ [ 1.0/float(components) for j in range(0, motif_length) ] for i in range(0, 4) ]
        mixture_weights = [ float(components-1)/float(components)*float(Gi.degree(v, weighted=True))/float(maximum_degree) for v in Gi ]
    else:
        components = len(Gi)
        motif = [ [ 0.001 for j in range(0, motif_length) ] for i in range(0, 4) ]
        mixture_weights = [ float(Gi.degree(v, weighted=True))/float(maximum_degree) for v in Gi ]
    for node, weight in zip(Gi.nodes(), mixture_weights):
        s = int(node.split(':')[0][1:])
        p = int(node.split(':')[1][:-1])
        for j in range(0, motif_length):
            if sequences[s][p+j] == 'A' or sequences[s][p+j] == 'a':
                motif[0][j] += weight/components
            if sequences[s][p+j] == 'C' or sequences[s][p+j] == 'c':
                motif[1][j] += weight/components
            if sequences[s][p+j] == 'G' or sequences[s][p+j] == 'g':
                motif[2][j] += weight/components
            if sequences[s][p+j] == 'T' or sequences[s][p+j] == 't':
                motif[3][j] += weight/components
    return motif, components

def generate_motifs(sequences, G, motif_length):
    Gcc = nx.connected_component_subgraphs(G)
    motifs = []
    motif_counts = []
    components = []
    for n, Gi in zip(range(0, len(Gcc)), Gcc):
        motif, comp = generate_motif(sequences, Gi, motif_length)
        motifs.append(motif)
        components.append(comp)
    for motif in motifs:
        # convert motifs to counts
        counts = [ [ int(round(motif[i][j]*1000)) for j in range(0, motif_length) ] for i in range(0, 4) ]
        motif_counts.append(counts)
    return motif_counts, components

# graph construction
# ------------------------------------------------------------------------------

def construct_graph(edges):
    G = nx.Graph()
    for edge in edges:
        e, w = edge.split('=')
        a, b = e.split('-')
        if float(w) > options['threshold']:
            G.add_edge(a, b, weight=float(w))
    return G

# plot
# ------------------------------------------------------------------------------

font = {'color'      : 'k',
        'fontweight' : 'bold',
        'fontsize'   : 14}

def plot_graph(G):
#    pos = nx.graphviz_layout(G, prog='twopi', args='')
#    pos = nx.graphviz_layout(G, prog='dot', args='')
#    pos = nx.graphviz_layout(G, prog='neato', args='')
    pos = nx.graphviz_layout(G, prog='circo', args='')
#    pos = nx.graphviz_layout(G, prog='nop', args='')
#    pos = nx.spring_layout(G)

    # create figure
    fig = pyplot.figure()
    ax  = fig.add_subplot(1,1,1)

    # compute edge and node sizes
    edgewidth  = [ d['weight'] for (u, v, d) in G.edges(data = True) ]
    max_weight = max(edgewidth)
    edgewidth  = [ 10.0*weight/max_weight for weight in edgewidth ]
    node_size  = [G.degree(v, weighted=True) for v in G]
    max_size   = max(node_size)
    node_size  = [ 500.0*size/max_size for size in node_size]

    # plot cluster labels
    Gcc = nx.connected_component_subgraphs(G)
    for n, Gi in zip(range(0, len(Gcc)), Gcc):
        center = map(lambda x: sum(x)/float(len(x)), zip(*[ pos[node] for node in Gi ]))
        ax.text(center[0], center[1]+10, 'Cluster %d' % n, font, alpha=0.2, ha='center', va='top')

    # plot graph
    nx.draw(G, pos, node_size=node_size, alpha=0.6, cmap=pyplot.cm.Reds_r, ax=ax)
    nx.draw_networkx_edges(G, pos, width=edgewidth, edge_color='r', alpha=0.2, ax=ax)

    pyplot.show()

def plot_result(G):
    if options['save']:
        importMatplotlib('Agg')
    else:
        importMatplotlib()
    plot_graph(G)

# main
# ------------------------------------------------------------------------------

def __main__(results_file, seq_file, motif_length):
    config_parser_results = ConfigParser.ConfigParser()
    config_parser_results.read(results_file)
    edges = parse_config(config_parser_results)
    descriptions, sequences = read_sequences(seq_file)
    G = construct_graph(edges)
    if options['plot'] or options['save']:
        if options['save']:
            config_parser_save = ConfigParser.ConfigParser()
            config_parser_save.read(options['save'])
        if options['load']:
            config_parser_load = ConfigParser.ConfigParser()
            config_parser_load.read(options['load'])
            bg, motifs, components = load_motifs(config_parser_load)
        else:
            bg = read_matrix(config_parser_results, 'Result', 'cluster_bg', int)
            motifs, components = generate_motifs(sequences, G, int(motif_length))
        if options['plot']:
            plot_motifs(motifs, components, os.path.splitext(results_file)[0])
        if options['save']:
            save_motifs(config_parser_save, bg, motifs, components)
            configfile = open(options['save'], 'wb')
            config_parser_save.write(configfile)
    else:
        plot_result(G)

def main():
    global options
    try:
        longopts   = ["help", "verbose", "plot", "with-prior=", "load=", "save=", "threshold="]
        opts, tail = getopt.getopt(sys.argv[1:], "pls:v", longopts)
    except getopt.GetoptError:
        usage()
        return 2
    output = None
    for o, a in opts:
        if o in ("-v", "--verbose"):
            sys.stderr.write("Verbose mode turned on.\n")
            options["verbose"] = True
        if o in ("-h", "--help"):
            usage()
            return 0
        if o == "--with-prior":
            if a == "Yes" or a == "yes":
                options['with-prior'] = True
            if a == "No" or a == "no":
                print "Neglecting uniform prior!"
                options['with-prior'] = False
        if o in ("-p", "--plot"):
            options['plot'] = True
        if o in ("-l", "--load"):
            options['load'] = a
        if o in ("-s", "--save"):
            options['save'] = a
        if o == "--threshold":
            options['threshold'] = float(a)
    if len(tail) != 3:
        usage()
        return 1
    __main__(*tail)
    return 0

if __name__ == "__main__":
    sys.exit(main())
